<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>××©×—×§ ×”××ª××˜×™×§×” ×©×œ ×ª×‘×•×¨ ğŸ‘‘</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+Hebrew:wght@300;400;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Noto Sans Hebrew', sans-serif;
            background: linear-gradient(45deg, #ff9a9e 0%, #fecfef 50%, #fecfef 100%);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }
        
        .math-text {
            direction: ltr;
            display: inline-block;
            font-family: 'Arial', sans-serif;
            font-weight: bold;
        }
        
        .stars {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            pointer-events: none;
        }
        
        .star {
            position: absolute;
            color: #ffd700;
            font-size: 20px;
            animation: twinkle 2s infinite;
        }
        
        @keyframes twinkle {
            0%, 100% { opacity: 0.3; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.2); }
        }
        
        .game-container {
            position: relative;
            z-index: 1;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            min-height: 100vh;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            animation: fadeInDown 1s ease-out;
        }
        
        .title {
            font-size: 2.5em;
            color: #8b5a96;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 1.3em;
            color: #d63384;
            margin-bottom: 20px;
        }
        
        .castle-progress {
            display: flex;
            justify-content: center;
            align-items: end;
            margin: 20px 0;
            height: 120px;
        }
        
        .castle-part {
            margin: 0 3px;
            font-size: 2em;
            opacity: 0.3;
            transition: all 0.5s ease;
            position: relative;
        }
        
        .castle-part.built {
            opacity: 1;
            transform: scale(1.1);
        }
        
        .level-indicator {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            background: #ffd700;
            color: #8b5a96;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 0.5em;
            font-weight: bold;
            min-width: 30px;
            text-align: center;
        }
        
        .score-board {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .score-item {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 25px;
            padding: 15px 25px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            text-align: center;
            border: 3px solid #ffd700;
            min-width: 120px;
        }
        
        .score-number {
            font-size: 1.8em;
            font-weight: bold;
            color: #8b5a96;
        }
        
        .score-label {
            font-size: 0.9em;
            color: #666;
            margin-top: 5px;
        }
        
        .menu-screen, .game-screen, .result-screen {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 30px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.1);
            text-align: center;
            border: 5px solid #ffd700;
        }
        
        .menu-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 25px;
            margin-top: 30px;
        }
        
        .menu-btn {
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
            border: none;
            border-radius: 20px;
            padding: 30px 20px;
            font-size: 1.3em;
            font-weight: bold;
            color: #8b5a96;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            border: 3px solid #ffd700;
        }
        
        .menu-btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 35px rgba(0,0,0,0.2);
        }
        
        .question-card {
            background: rgba(255, 255, 255, 0.98);
            border-radius: 25px;
            padding: 40px;
            margin: 20px 0;
            box-shadow: 0 15px 45px rgba(0,0,0,0.1);
            border: 4px solid #ffd700;
            animation: slideInUp 0.6s ease-out;
            min-height: 350px;
        }
        
        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            font-size: 1.1em;
            color: #8b5a96;
        }
        
        .current-level {
            background: linear-gradient(135deg, #8b5a96 0%, #ce93d8 100%);
            color: white;
            padding: 8px 15px;
            border-radius: 15px;
            font-weight: bold;
        }
        
        .question-text {
            font-size: 1.8em;
            color: #8b5a96;
            margin-bottom: 30px;
            line-height: 1.4;
            font-weight: bold;
        }
        
        .question-image {
            max-width: 100%;
            height: auto;
            margin: 20px 0;
            border-radius: 15px;
        }
        
        .answers-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 30px;
        }
        
        .answer-btn {
            background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%);
            border: 3px solid #9c27b0;
            border-radius: 15px;
            padding: 20px 15px;
            font-size: 1.2em;
            font-weight: bold;
            color: #8b5a96;
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 70px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .answer-btn:hover {
            background: linear-gradient(135deg, #ce93d8 0%, #f8bbd9 100%);
            transform: scale(1.05);
        }
        
        .answer-btn.correct {
            background: linear-gradient(135deg, #4caf50 0%, #81c784 100%);
            color: white;
            animation: correctAnswer 1s ease-in-out;
        }
        
        .answer-btn.incorrect {
            background: linear-gradient(135deg, #f44336 0%, #ef5350 100%);
            color: white;
            animation: incorrectAnswer 0.8s ease-in-out;
        }
        
        @keyframes correctAnswer {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1.1); }
        }
        
        @keyframes incorrectAnswer {
            0% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
            100% { transform: translateX(0); }
        }
        
        .feedback {
            margin: 25px 0;
            padding: 20px;
            border-radius: 15px;
            font-size: 1.4em;
            font-weight: bold;
            opacity: 0;
            transition: all 0.5s ease;
        }
        
        .feedback.show {
            opacity: 1;
        }
        
        .feedback.positive {
            background: linear-gradient(135deg, #4caf50 0%, #81c784 100%);
            color: white;
        }
        
        .feedback.negative {
            background: linear-gradient(135deg, #ff9800 0%, #ffb74d 100%);
            color: white;
        }
        
        .next-btn, .back-btn {
            background: linear-gradient(135deg, #8b5a96 0%, #ce93d8 100%);
            border: none;
            border-radius: 15px;
            padding: 15px 30px;
            font-size: 1.2em;
            font-weight: bold;
            color: white;
            cursor: pointer;
            margin: 20px 10px;
            transition: all 0.3s ease;
            border: 3px solid #ffd700;
        }
        
        .next-btn:hover, .back-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.2);
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            margin: 20px 0;
            overflow: hidden;
            border: 2px solid #ffd700;
            position: relative;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff9a9e 0%, #fecfef 100%);
            border-radius: 10px;
            transition: width 0.5s ease;
        }
        
        .progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #8b5a96;
            font-weight: bold;
            font-size: 0.9em;
        }
        
        .fireworks {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }
        
        .firework {
            position: absolute;
            font-size: 2em;
            animation: explode 1s ease-out forwards;
        }
        
        @keyframes explode {
            0% { 
                transform: scale(0) rotate(0deg);
                opacity: 1;
            }
            100% { 
                transform: scale(2) rotate(360deg);
                opacity: 0;
            }
        }
        
        .level-up-notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #ffd700 0%, #ffeb3b 100%);
            color: #8b5a96;
            padding: 30px 50px;
            border-radius: 25px;
            font-size: 2em;
            font-weight: bold;
            z-index: 1001;
            text-align: center;
            border: 4px solid #ff9a9e;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            animation: levelUpAnimation 3s ease-in-out forwards;
        }
        
        @keyframes levelUpAnimation {
            0% { 
                transform: translate(-50%, -50%) scale(0);
                opacity: 0;
            }
            20% { 
                transform: translate(-50%, -50%) scale(1.2);
                opacity: 1;
            }
            80% { 
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
            100% { 
                transform: translate(-50%, -50%) scale(0);
                opacity: 0;
            }
        }
        
        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .hidden {
            display: none !important;
        }
        
        @media (max-width: 768px) {
            .game-container {
                padding: 10px;
            }
            
            .title {
                font-size: 2em;
            }
            
            .menu-btn {
                padding: 25px 15px;
                font-size: 1.1em;
            }
            
            .question-card {
                padding: 25px;
            }
            
            .question-text {
                font-size: 1.4em;
            }
            
            .answer-btn {
                padding: 15px 10px;
                font-size: 1em;
            }
            
            .score-board {
                gap: 15px;
            }
            
            .score-item {
                padding: 10px 15px;
                min-width: 100px;
            }
        }
    </style>
</head>
<body>
    <div class="stars" id="stars"></div>
    
    <div class="game-container">
        <div class="header">
            <h1 class="title">××©×—×§ ×”××ª××˜×™×§×” ×©×œ ×ª×‘×•×¨ ğŸ‘‘</h1>
            <p class="subtitle">×¤×™×™×ª ×”××ª××˜×™×§×” ××–××™× ×” ××•×ª×š ×œ×”×¨×¤×ª×§×” ×©×œ 10 ×¨××•×ª! âœ¨</p>
        </div>
        
        <div class="castle-progress" id="castleProgress">
            <div class="castle-part" id="castle1">ğŸ°<div class="level-indicator">1</div></div>
            <div class="castle-part" id="castle2">ğŸ¯<div class="level-indicator">2</div></div>
            <div class="castle-part" id="castle3">ğŸ—¼<div class="level-indicator">3</div></div>
            <div class="castle-part" id="castle4">ğŸ‘‘<div class="level-indicator">4</div></div>
            <div class="castle-part" id="castle5">ğŸª<div class="level-indicator">5</div></div>
            <div class="castle-part" id="castle6">ğŸ¡<div class="level-indicator">6</div></div>
            <div class="castle-part" id="castle7">ğŸ¢<div class="level-indicator">7</div></div>
            <div class="castle-part" id="castle8">ğŸ <div class="level-indicator">8</div></div>
            <div class="castle-part" id="castle9">ğŸ†<div class="level-indicator">9</div></div>
            <div class="castle-part" id="castle10">ğŸ‘¸<div class="level-indicator">10</div></div>
        </div>
        
        <div class="score-board">
            <div class="score-item">
                <div class="score-number" id="currentScore">0</div>
                <div class="score-label">×›×•×›×‘×™× â­</div>
            </div>
            <div class="score-item">
                <div class="score-number" id="currentLevel">1</div>
                <div class="score-label">×¨××” ğŸŒŸ</div>
            </div>
            <div class="score-item">
                <div class="score-number" id="correctAnswers">0/15</div>
                <div class="score-label">× ×›×•× ×•×ª ğŸ’œ</div>
            </div>
        </div>
        
        <!-- Main Menu Screen -->
        <div class="menu-screen" id="menuScreen">
            <h2 style="color: #8b5a96; font-size: 1.8em; margin-bottom: 20px;">
                ×©×œ×•× ×ª×‘×•×¨ ×”×™×§×¨×”! ğŸ‘¸ ×‘××™×–×” × ×•×©× × ×ª×¨×’×œ ×”×™×•×?
            </h2>
            <div class="menu-buttons">
                <button class="menu-btn" onclick="startGame('numbers')">
                    ğŸ”¢ ××¡×¤×¨×™× ×˜×‘×¢×™×™×<br>
                    <small>10 ×¨××•×ª ×-10 ×¢×“ 1000</small>
                </button>
                <button class="menu-btn" onclick="startGame('operations')">
                    â• ×¤×¢×•×œ×•×ª ×—×©×‘×•×Ÿ<br>
                    <small>×œ×•×— ×›×¤×œ ××“×•×¨×’ ×‘-10 ×¨××•×ª</small>
                </button>
                <button class="menu-btn" onclick="startGame('geometry')">
                    ğŸ“ ×’××•××˜×¨×™×”<br>
                    <small>×–×•×•×™×•×ª ×•××©×•×œ×©×™× ×‘-10 ×¨××•×ª</small>
                </button>
            </div>
            <div style="margin-top: 30px; color: #8b5a96; font-size: 1.1em;">
                <strong>××¢×¨×›×ª ×¨××•×ª ×—×“×©×”:</strong><br>
                ×›×œ ×¨××” = 15 ×©××œ×•×ª | 10 ×¨××•×ª ×§×•×©×™ ××“×•×¨×’×•×ª | ×”×ª×§×“××•×ª ×”×“×¨×’×ª×™×ª
            </div>
        </div>
        
        <!-- Game Screen -->
        <div class="game-screen hidden" id="gameScreen">
            <div class="question-header">
                <div class="current-level">×¨××” <span id="levelDisplay">1</span></div>
                <div style="color: #8b5a96;">×©××œ×” <span id="questionNumber">1</span> ××ª×•×š 15</div>
            </div>
            
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                <div class="progress-text" id="progressText">0%</div>
            </div>
            
            <div class="question-card" id="questionCard">
                <div class="question-text" id="questionText">×˜×•×¢×Ÿ ×©××œ×”...</div>
                <div id="questionImage"></div>
                <div class="answers-grid" id="answersGrid">
                    <!-- Answers will be populated here -->
                </div>
            </div>
            
            <div class="feedback" id="feedback"></div>
            
            <div>
                <button class="back-btn" onclick="showMenu()">×—×–×•×¨ ×œ×ª×¤×¨×™×˜ ğŸ </button>
                <button class="next-btn hidden" id="nextBtn" onclick="nextQuestion()">×©××œ×” ×”×‘××” â¡ï¸</button>
            </div>
        </div>
        
        <!-- Result Screen -->
        <div class="result-screen hidden" id="resultScreen">
            <h2 style="color: #8b5a96; font-size: 2.2em; margin-bottom: 20px;" id="resultTitle"></h2>
            <div id="resultMessage" style="font-size: 1.4em; margin: 20px 0;"></div>
            <div>
                <button class="next-btn" onclick="showMenu()">×ª×¤×¨×™×˜ ×¨××©×™ ğŸ </button>
                <button class="next-btn" onclick="nextLevel()">×¨××” ×”×‘××”! ğŸš€</button>
            </div>
        </div>
    </div>
    
    <div class="fireworks" id="fireworks"></div>

    <script>
        console.log('ğŸ® ××©×—×§ ×”××ª××˜×™×§×” ×”××ª×§×“× ×©×œ ×ª×‘×•×¨ × ×˜×¢×Ÿ...');
        
        // Game State
        let gameState = {
            currentTopic: '',
            currentLevel: 1,
            currentQuestion: 0,
            score: 0,
            correctAnswersInRow: 0,
            questions: []
        };
        
        // Question generators for different levels
        const questionGenerators = {
            numbers: {
                1: () => generateNumberQuestions(1, 50, 'basic'),
                2: () => generateNumberQuestions(1, 100, 'sequences'),
                3: () => generateNumberQuestions(50, 200, 'comparison'),
                4: () => generateNumberQuestions(100, 300, 'place_value'),
                5: () => generateNumberQuestions(200, 500, 'advanced_sequences'),
                6: () => generateNumberQuestions(300, 600, 'complex_comparison'),
                7: () => generateNumberQuestions(400, 700, 'mixed_operations'),
                8: () => generateNumberQuestions(500, 800, 'word_problems'),
                9: () => generateNumberQuestions(600, 900, 'complex_patterns'),
                10: () => generateNumberQuestions(700, 1000, 'master_level')
            },
            operations: {
                1: () => generateMultiplicationQuestions([1, 2, 5, 10]),
                2: () => generateMultiplicationQuestions([2, 3, 4, 5]),
                3: () => generateMultiplicationQuestions([4, 5, 6, 7]),
                4: () => generateMultiplicationQuestions([5, 6, 7, 8]),
                5: () => generateMultiplicationQuestions([6, 7, 8, 9]),
                6: () => generateMixedOperations('intermediate'),
                7: () => generateMixedOperations('advanced'), 
                8: () => generateComplexOperations(),
                9: () => generateMasterOperations(),
                10: () => generateUltimateOperations()
            },
            geometry: {
                1: () => generateGeometryQuestions('basic_angles'),
                2: () => generateGeometryQuestions('angle_types'),
                3: () => generateGeometryQuestions('basic_triangles'),
                4: () => generateGeometryQuestions('triangle_types'),
                5: () => generateGeometryQuestions('angle_measurement'),
                6: () => generateGeometryQuestions('triangle_properties'),
                7: () => generateGeometryQuestions('mixed_shapes'),
                8: () => generateGeometryQuestions('complex_angles'),
                9: () => generateGeometryQuestions('advanced_triangles'),
                10: () => generateGeometryQuestions('geometry_master')
            }
        };

        // Utility function to shuffle array and return correct index
        function shuffleAnswers(answers, correctAnswer = null) {
            // If correctAnswer is provided, find it in the array
            if (correctAnswer !== null) {
                const correctIndex = answers.indexOf(correctAnswer);
                if (correctIndex === -1) {
                    answers[0] = correctAnswer; // Ensure correct answer is in array
                }
            }
            
            const correct = correctAnswer || answers[0];
            const shuffled = [...answers].sort(() => Math.random() - 0.5);
            const newCorrectIndex = shuffled.indexOf(correct);
            
            return {
                answers: shuffled,
                correctIndex: newCorrectIndex
            };
        }

        // Generate number questions based on level
        function generateNumberQuestions(min, max, type) {
            const questions = [];
            
            for (let i = 0; i < 15; i++) {
                let question;
                
                switch(type) {
                    case 'basic':
                        question = generateBasicNumberQuestion(min, max);
                        break;
                    case 'sequences':
                        question = generateSequenceQuestion(min, max);
                        break;
                    case 'comparison':
                        question = generateComparisonQuestion(min, max);
                        break;
                    case 'place_value':
                        question = generatePlaceValueQuestion(min, max);
                        break;
                    default:
                        question = generateBasicNumberQuestion(min, max);
                }
                
                questions.push(question);
            }
            
            return questions;
        }

        // Generate basic number questions
        function generateBasicNumberQuestion(min, max) {
            const num = Math.floor(Math.random() * (max - min + 1)) + min;
            const type = Math.floor(Math.random() * 3);
            
            switch(type) {
                case 0: // Next number
                    const nextAnswers = [num + 1, num - 1, num + 2, num - 2];
                    const nextShuffled = shuffleAnswers(nextAnswers, num + 1);
                    return {
                        question: `××” ×”××¡×¤×¨ ×©×‘× ××—×¨×™ ${num}?`,
                        answers: nextShuffled.answers,
                        correct: nextShuffled.correctIndex,
                        tip: `×”××¡×¤×¨ ×”×¢×•×§×‘ ×œ-${num} ×”×•× ${num + 1}`
                    };
                    
                case 1: // Previous number
                    const prevAnswers = [num - 1, num + 1, num - 2, num + 2];
                    const prevShuffled = shuffleAnswers(prevAnswers, num - 1);
                    return {
                        question: `××” ×”××¡×¤×¨ ×©×‘× ×œ×¤× ×™ ${num}?`,
                        answers: prevShuffled.answers,
                        correct: prevShuffled.correctIndex,
                        tip: `×”××¡×¤×¨ ×”×§×•×“× ×œ-${num} ×”×•× ${num - 1}`
                    };
                    
                case 2: // Largest number
                    const nums = [num, num + 10, num - 5, num + 15];
                    const largest = Math.max(...nums);
                    const largestShuffled = shuffleAnswers(nums.map(n => n.toString()), largest.toString());
                    return {
                        question: `××™×–×” ××¡×¤×¨ ×”×•× ×”×’×“×•×œ ×‘×™×•×ª×¨?`,
                        answers: largestShuffled.answers,
                        correct: largestShuffled.correctIndex,
                        tip: `×”××¡×¤×¨ ×”×’×“×•×œ ×‘×™×•×ª×¨ ×”×•× ${largest}`
                    };
            }
        }

        // Generate sequence questions
        function generateSequenceQuestion(min, max) {
            const start = Math.floor(Math.random() * (max - min - 20)) + min;
            const step = [5, 10, 2, 3][Math.floor(Math.random() * 4)];
            const sequence = [start, start + step, start + 2*step];
            const missing = start + 3*step;
            
            const seqAnswers = [missing, missing + step, missing - step, missing + 5];
            const seqShuffled = shuffleAnswers(seqAnswers.map(n => n.toString()), missing.toString());
            
            return {
                question: `××” ×”××¡×¤×¨ ×”×—×¡×¨: ${sequence[0]}, ${sequence[1]}, ${sequence[2]}, ___`,
                answers: seqShuffled.answers,
                correct: seqShuffled.correctIndex,
                tip: `×”×¡×“×¨×” ×¢×•×œ×” ×‘-${step}, ××– ×”×ª×©×•×‘×” ×”×™× ${missing}`
            };
        }

        // Generate multiplication questions by level
        function generateMultiplicationQuestions(tables) {
            const questions = [];
            
            for (let i = 0; i < 15; i++) {
                const table = tables[Math.floor(Math.random() * tables.length)];
                const multiplier = Math.floor(Math.random() * 9) + 1;
                const result = table * multiplier;
                
                const wrongAnswers = [
                    result + table,
                    result - table, 
                    result + multiplier
                ];
                
                const multAnswers = [result, ...wrongAnswers];
                const multShuffled = shuffleAnswers(multAnswers.map(n => n.toString()), result.toString());
                
                questions.push({
                    question: `×›××” ×–×” <span class='math-text'>${table} Ã— ${multiplier}</span>? âœ¨`,
                    answers: multShuffled.answers,
                    correct: multShuffled.correctIndex,
                    tip: `${table} ×›×¤×•×œ ${multiplier} = ${result}. ×˜×™×¤: ${getMultiplicationTip(table, multiplier)}`
                });
            }
            
            return questions;
        }

        // Generate geometry questions by type
        function generateGeometryQuestions(type) {
            const questions = [];
            
            const templates = {
                basic_angles: [
                    {
                        question: "××™×–×” ×¡×•×’ ×–×•×•×™×ª ×–×”? (×¤×—×•×ª ×-90 ××¢×œ×•×ª)",
                        image: "ğŸ”º",
                        answers: ["×–×•×•×™×ª ×—×“×”", "×–×•×•×™×ª ×™×©×¨×”", "×–×•×•×™×ª ×§×”×”", "×–×•×•×™×ª ×©×˜×•×—×”"],
                        correct: 0,
                        tip: "×–×•×•×™×ª ×—×“×” ×§×˜× ×” ×-90 ××¢×œ×•×ª"
                    },
                    {
                        question: "××™×–×” ×¡×•×’ ×–×•×•×™×ª ×–×”? (×‘×“×™×•×§ 90 ××¢×œ×•×ª)",
                        image: "ğŸ“",
                        answers: ["×–×•×•×™×ª ×—×“×”", "×–×•×•×™×ª ×™×©×¨×”", "×–×•×•×™×ª ×§×”×”", "×–×•×•×™×ª ×©×˜×•×—×”"],
                        correct: 1,
                        tip: "×–×•×•×™×ª ×™×©×¨×” ×”×™× ×‘×“×™×•×§ 90 ××¢×œ×•×ª"
                    },
                    {
                        question: "××™×–×” ×¡×•×’ ×–×•×•×™×ª ×–×”? (×™×•×ª×¨ ×-90 ××¢×œ×•×ª)",
                        image: "ğŸ“",
                        answers: ["×–×•×•×™×ª ×—×“×”", "×–×•×•×™×ª ×™×©×¨×”", "×–×•×•×™×ª ×§×”×”", "×–×•×•×™×ª ×©×˜×•×—×”"],
                        correct: 2,
                        tip: "×–×•×•×™×ª ×§×”×” ×’×“×•×œ×” ×-90 ××¢×œ×•×ª"
                    }
                ],
                angle_types: [
                    {
                        question: "×›××” ××¢×œ×•×ª ×™×© ×‘×–×•×•×™×ª ×™×©×¨×”?",
                        answers: ["90", "180", "45", "360"],
                        correct: 0,
                        tip: "×–×•×•×™×ª ×™×©×¨×” = 90 ××¢×œ×•×ª ×ª××™×“"
                    },
                    {
                        question: "××™×–×• ×–×•×•×™×ª ×’×“×•×œ×” ×-90 ××¢×œ×•×ª ××‘×œ ×§×˜× ×” ×-180?",
                        answers: ["×–×•×•×™×ª ×—×“×”", "×–×•×•×™×ª ×™×©×¨×”", "×–×•×•×™×ª ×§×”×”", "×–×•×•×™×ª ×©×˜×•×—×”"],
                        correct: 2,
                        tip: "×–×•×•×™×ª ×§×”×” × ××¦××ª ×‘×™×Ÿ 90 ×œ-180 ××¢×œ×•×ª"
                    }
                ]
            };
            
            const typeQuestions = templates[type] || templates.basic_angles;
            
            for (let i = 0; i < 15; i++) {
                const baseQuestion = typeQuestions[i % typeQuestions.length];
                const variation = generateGeometryVariation(baseQuestion, type, i);
                questions.push(variation);
            }
            
            return questions;
        }

        // Additional generator functions
        function generateComparisonQuestion(min, max) {
            return generateBasicNumberQuestion(min, max);
        }

        function generatePlaceValueQuestion(min, max) {
            const num = Math.floor(Math.random() * (max - min + 1)) + min;
            const digits = num.toString();
            const place = Math.floor(Math.random() * digits.length);
            const placeName = ['××—×“×•×ª', '×¢×©×¨×•×ª', '×××•×ª'][digits.length - 1 - place] || '××—×“×•×ª';
            
            const placeAnswers = [
                digits[place],
                digits[(place + 1) % digits.length] || '0',
                digits[(place + 2) % digits.length] || '0',
                (parseInt(digits[place]) + 1).toString()
            ];
            
            const placeShuffled = shuffleAnswers(placeAnswers, digits[place]);
            
            return {
                question: `×›××” ${placeName} ×™×© ×‘××¡×¤×¨ ${num}?`,
                answers: placeShuffled.answers,
                correct: placeShuffled.correctIndex,
                tip: `×‘××¡×¤×¨ ${num}, ×‘${placeName} ×™×© ${digits[place]}`
            };
        }

        function generateMixedOperations(level) {
            const questions = [];
            
            for (let i = 0; i < 15; i++) {
                const operations = level === 'intermediate' ? 
                    ['addition', 'subtraction', 'multiplication'] :
                    ['addition', 'subtraction', 'multiplication', 'division'];
                
                const op = operations[Math.floor(Math.random() * operations.length)];
                questions.push(generateOperationQuestion(op, level));
            }
            
            return questions;
        }

        function generateOperationQuestion(operation, level) {
            let a, b, result, question, tip;
            
            const range = level === 'intermediate' ? [10, 50] : [20, 100];
            
            switch(operation) {
                case 'addition':
                    a = Math.floor(Math.random() * range[1]) + range[0];
                    b = Math.floor(Math.random() * range[1]) + range[0];
                    result = a + b;
                    question = `×›××” ×–×” <span class='math-text'>${a} + ${b}</span>?`;
                    tip = `${a} ×•×¢×•×“ ${b} ×©×•×•×” ${result}`;
                    break;
                    
                case 'subtraction':
                    result = Math.floor(Math.random() * range[1]) + range[0];
                    b = Math.floor(Math.random() * result);
                    a = result + b;
                    question = `×›××” ×–×” <span class='math-text'>${a} - ${b}</span>?`;
                    tip = `${a} ×¤×—×•×ª ${b} ×©×•×•×” ${result}`;
                    break;
                    
                case 'multiplication':
                    a = Math.floor(Math.random() * 9) + 2;
                    b = Math.floor(Math.random() * 9) + 2;
                    result = a * b;
                    question = `×›××” ×–×” <span class='math-text'>${a} Ã— ${b}</span>? ğŸŒŸ`;
                    tip = `${a} ×›×¤×•×œ ${b} ×©×•×•×” ${result}`;
                    break;
                    
                case 'division':
                    result = Math.floor(Math.random() * 10) + 2;
                    b = Math.floor(Math.random() * 8) + 2;
                    a = result * b;
                    question = `×›××” ×–×” <span class='math-text'>${a} Ã· ${b}</span>?`;
                    tip = `${a} ×—×œ×§×™ ${b} ×©×•×•×” ${result}`;
                    break;
            }
            
            const wrongAnswers = [
                result + 1,
                result - 1,
                result + Math.floor(Math.random() * 5) + 2
            ];
            
            const opAnswers = [result, ...wrongAnswers];
            const opShuffled = shuffleAnswers(opAnswers.map(n => n.toString()), result.toString());
            
            return {
                question,
                answers: opShuffled.answers,
                correct: opShuffled.correctIndex,
                tip
            };
        }

        function generateComplexOperations() {
            return generateMixedOperations('advanced');
        }

        function generateMasterOperations() {
            return generateMixedOperations('advanced');
        }

        function generateUltimateOperations() {
            return generateMixedOperations('advanced');
        }

        function getMultiplicationTip(a, b) {
            const tips = [
                `×—×©×‘×™ ×¢×œ ${a} ×§×‘×•×¦×•×ª ×©×œ ${b}`,
                `×›××• ${b} ×¤×¢××™× ${a}`,
                `×¡×¤×¨×™ ×‘×§×¤×™×¦×•×ª ×©×œ ${a}`
            ];
            return tips[Math.floor(Math.random() * tips.length)];
        }

        function generateGeometryVariation(base, type, index) {
            const variation = {...base};
            
            if (type.includes('angles')) {
                const angles = ['×—×“×”', '×™×©×¨×”', '×§×”×”', '×©×˜×•×—×”'];
                const degrees = ['30Â°', '90Â°', '120Â°', '180Â°'];
                const emojis = ['ğŸ”º', 'ğŸ“', 'ğŸ“', 'â¡ï¸'];
                
                const angleType = index % 4;
                variation.question = `××™×–×• ×–×•×•×™×ª ×©×œ ${degrees[angleType]} ×”×™× ×–×•×•×™×ª...?`;
                
                const angleAnswers = [`×–×•×•×™×ª ${angles[angleType]}`, ...angles.filter(a => a !== angles[angleType]).slice(0, 3)];
                const angleShuffled = shuffleAnswers(angleAnswers, `×–×•×•×™×ª ${angles[angleType]}`);
                
                variation.answers = angleShuffled.answers;
                variation.correct = angleShuffled.correctIndex;
                variation.image = emojis[angleType];
            }
            
            return variation;
        }

        // Positive feedback messages
        const positiveFeedback = [
            "×ª×‘×•×¨, ××™×–×• ××œ×•×¤×”! ×”××©×™×›×™ ×›×š! ğŸ‘‘",
            "××ª ××œ×•×¤×ª ×”××ª××˜×™×§×”! â­",
            "××“×”×™× ×ª×‘×•×¨! ××ª ×¤×©×•×˜ × ×¤×œ××”! âœ¨",
            "×‘×“×™×•×§ × ×›×•×Ÿ! ××ª ××•×©×œ××ª! ğŸ’œ",
            "×•×•××• ×ª×‘×•×¨! ××™×–×• ×ª×©×•×‘×” × ×¤×œ××”! ğŸŒŸ",
            "××¦×•×™×Ÿ! ×”×˜×™×¨×” ×©×œ×š ×’×“×œ×”! ğŸ°",
            "×ª×‘×•×¨ ×’××•× ×™×ª! ×¨××” ×”×‘××” ××—×›×”! ğŸš€",
            "×¤× ×˜×¡×˜×™! ××ª ××ª×§×“××ª ×‘×¦×•×¨×” ××•×©×œ××ª! ğŸ’«"
        ];

        // Negative feedback messages
        const negativeFeedback = [
            "×œ× × ×•×¨× ×ª×‘×•×¨, × × ×¡×” ×©×•×‘! ××ª ×™×›×•×œ×”! ğŸ’œ",
            "×›××¢×˜ ×”×’×¢×ª! ×‘×•××™ × × ×¡×” ×¤×¢× × ×•×¡×¤×ª ğŸŒŸ",
            "×–×” ×‘×¡×“×¨ ×œ×˜×¢×•×ª, ×–×” ××™×š ×œ×•××“×™×! ×‘×•××™ ×©×•×‘! âœ¨",
            "×ª×‘×•×¨, ××ª ×—×›××” ×•×™×›×•×œ×”! ×¢×•×“ × ×¡×™×•×Ÿ! ğŸ‘‘",
            "×œ× ×‘×“×™×•×§, ××‘×œ ××ª ×‘×“×¨×š ×”× ×›×•× ×”! ğŸ’–",
            "×›××¢×˜! ×‘×•××™ × ×—×©×•×‘ ×™×—×“ ×¢×œ ×–×” ğŸ¤”"
        ];

        // Initialize game
        function initGame() {
            console.log('ğŸ¯ ××ª×—×™×œ ××ª×—×•×œ ×”××©×—×§ ×”××ª×§×“×...');
            try {
                createStars();
                loadGameState();
                updateDisplay();
                console.log('âœ… ×”××©×—×§ ×”××ª×§×“× × ×˜×¢×Ÿ ×‘×”×¦×œ×—×”!');
            } catch (error) {
                console.error('âŒ ×©×’×™××” ×‘××ª×—×•×œ ×”××©×—×§:', error);
            }
        }

        // Create animated stars background
        function createStars() {
            console.log('â­ ×™×•×¦×¨ ×›×•×›×‘×™×...');
            const starsContainer = document.getElementById('stars');
            starsContainer.innerHTML = '';
            
            for (let i = 0; i < 50; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.textContent = 'â­';
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                star.style.animationDelay = Math.random() * 2 + 's';
                starsContainer.appendChild(star);
            }
        }

        // Start game with selected topic
        function startGame(topic) {
            console.log(`ğŸ® ××ª×—×™×œ ××©×—×§ ×‘× ×•×©×: ${topic}, ×¨××”: ${gameState.currentLevel}`);
            
            try {
                gameState.currentTopic = topic;
                gameState.currentQuestion = 0;
                gameState.correctAnswersInRow = 0;
                
                // Generate questions for current level
                const generator = questionGenerators[topic][gameState.currentLevel];
                gameState.questions = generator ? generator() : [];
                
                console.log(`ğŸ“ × ×•×¦×¨×• ${gameState.questions.length} ×©××œ×•×ª ×œ×¨××” ${gameState.currentLevel}`);
                console.log('×“×•×’××” ×œ×©××œ×”:', gameState.questions[0]);
                
                // Show game screen
                document.getElementById('menuScreen').classList.add('hidden');
                document.getElementById('gameScreen').classList.remove('hidden');
                document.getElementById('resultScreen').classList.add('hidden');
                
                // Update level display
                document.getElementById('levelDisplay').textContent = gameState.currentLevel;
                
                // Show first question
                showQuestion();
                
            } catch (error) {
                console.error('âŒ ×©×’×™××” ×‘×”×ª×—×œ×ª ×”××©×—×§:', error);
            }
        }

        // Show current question
        function showQuestion() {
            console.log(`â“ ××¦×™×’ ×©××œ×” ${gameState.currentQuestion + 1}/15 ×‘×¨××” ${gameState.currentLevel}`);
            
            try {
                if (!gameState.questions || gameState.currentQuestion >= gameState.questions.length) {
                    console.log('ğŸ ×¡×™×•× ×”×¨××”');
                    showResults();
                    return;
                }
                
                const question = gameState.questions[gameState.currentQuestion];
                console.log('ğŸ“‹ ×”×©××œ×”:', question);
                
                // Update question text
                document.getElementById('questionText').innerHTML = question.question;
                document.getElementById('questionNumber').textContent = gameState.currentQuestion + 1;
                
                // Hide next button and feedback
                document.getElementById('nextBtn').classList.add('hidden');
                document.getElementById('feedback').classList.remove('show');
                
                // Show image if exists
                const imageContainer = document.getElementById('questionImage');
                if (question.image) {
                    imageContainer.innerHTML = `<div style="font-size: 4em; margin: 20px 0;">${question.image}</div>`;
                } else {
                    imageContainer.innerHTML = '';
                }
                
                // Create answer buttons
                const answersGrid = document.getElementById('answersGrid');
                answersGrid.innerHTML = '';
                
                console.log('ğŸ”˜ ×™×•×¦×¨ ×›×¤×ª×•×¨×™ ×ª×©×•×‘×•×ª:', question.answers);
                
                question.answers.forEach((answer, index) => {
                    const btn = document.createElement('button');
                    btn.className = 'answer-btn';
                    btn.innerHTML = answer;
                    btn.onclick = () => selectAnswer(index);
                    answersGrid.appendChild(btn);
                    console.log(`×›×¤×ª×•×¨ ${index}: ${answer}`);
                });
                
                updateProgress();
                console.log('âœ… ×”×©××œ×” ×”×•×¦×’×” ×‘×”×¦×œ×—×”!');
                
            } catch (error) {
                console.error('âŒ ×©×’×™××” ×‘×”×¦×’×ª ×”×©××œ×”:', error);
            }
        }

        // Handle answer selection
        function selectAnswer(selectedIndex) {
            console.log('ğŸ‘† × ×‘×—×¨×” ×ª×©×•×‘×”:', selectedIndex);
            
            try {
                const question = gameState.questions[gameState.currentQuestion];
                const buttons = document.querySelectorAll('.answer-btn');
                
                // Disable all buttons
                buttons.forEach(btn => btn.style.pointerEvents = 'none');
                
                if (selectedIndex === question.correct) {
                    console.log('âœ… ×ª×©×•×‘×” × ×›×•× ×”!');
                    
                    buttons[selectedIndex].classList.add('correct');
                    gameState.score += 10;
                    gameState.correctAnswersInRow++;
                    
                    showFeedback(true, positiveFeedback[Math.floor(Math.random() * positiveFeedback.length)]);
                    createFireworks();
                    
                } else {
                    console.log('âŒ ×ª×©×•×‘×” ×©×’×•×™×”');
                    
                    buttons[selectedIndex].classList.add('incorrect');
                    buttons[question.correct].classList.add('correct');
                    
                    showFeedback(false, negativeFeedback[Math.floor(Math.random() * negativeFeedback.length)] + '<br><small>' + question.tip + '</small>');
                }
                
                updateDisplay();
                
                // Show next button after delay
                setTimeout(() => {
                    document.getElementById('nextBtn').classList.remove('hidden');
                }, 2000);
                
            } catch (error) {
                console.error('âŒ ×©×’×™××” ×‘×‘×—×™×¨×ª ×ª×©×•×‘×”:', error);
            }
        }

        // Show feedback message
        function showFeedback(isPositive, message) {
            try {
                const feedback = document.getElementById('feedback');
                feedback.innerHTML = message;
                feedback.className = 'feedback show ' + (isPositive ? 'positive' : 'negative');
            } catch (error) {
                console.error('âŒ ×©×’×™××” ×‘×”×¦×’×ª ××©×•×‘:', error);
            }
        }

        // Create fireworks animation
        function createFireworks() {
            try {
                const fireworksContainer = document.getElementById('fireworks');
                const emojis = ['ğŸ‰', 'âœ¨', 'â­', 'ğŸŒŸ', 'ğŸ’«', 'ğŸŠ'];
                
                for (let i = 0; i < 15; i++) {
                    setTimeout(() => {
                        const firework = document.createElement('div');
                        firework.className = 'firework';
                        firework.textContent = emojis[Math.floor(Math.random() * emojis.length)];
                        firework.style.left = Math.random() * 100 + '%';
                        firework.style.top = Math.random() * 100 + '%';
                        fireworksContainer.appendChild(firework);
                        
                        setTimeout(() => firework.remove(), 1000);
                    }, i * 100);
                }
            } catch (error) {
                console.error('âŒ ×©×’×™××” ×‘×–×™×§×•×§×™×:', error);
            }
        }

        // Next question
        function nextQuestion() {
            console.log('â¡ï¸ ×¢×•×‘×¨ ×œ×©××œ×” ×”×‘××”...');
            
            try {
                gameState.currentQuestion++;
                
                if (gameState.currentQuestion >= 15) {
                    console.log('ğŸ ×¡×™×•× ×”×¨××”');
                    showResults();
                } else {
                    showQuestion();
                }
            } catch (error) {
                console.error('âŒ ×©×’×™××” ×‘××¢×‘×¨ ×œ×©××œ×” ×”×‘××”:', error);
            }
        }

        // Show results screen
        function showResults() {
            try {
                document.getElementById('gameScreen').classList.add('hidden');
                document.getElementById('resultScreen').classList.remove('hidden');
                
                const percentage = Math.round((gameState.correctAnswersInRow / 15) * 100);
                
                let title, message;
                
                if (percentage >= 80) {
                    title = '×ª×‘×•×¨ ×”××“×”×™××”! ×¢×œ×™×ª ×œ×¨××” ×”×‘××”! ğŸ‘‘ğŸš€';
                    message = `××¢×•×œ×”! ×”×©×’×ª ${percentage}% × ×›×•× ×•×ª!<br>
                              ×¦×‘×¨×ª ${gameState.correctAnswersInRow} ×ª×©×•×‘×•×ª × ×›×•× ×•×ª ××ª×•×š 15<br>
                              ğŸŒŸ ×¨××” ${gameState.currentLevel} ×”×•×©×œ××” ×‘×”×¦×œ×—×”! ğŸŒŸ<br>
                              ××•×›× ×” ×œ×¨××” ${gameState.currentLevel + 1}?`;
                    
                    // Level up if score is good enough
                    if (gameState.currentLevel < 10) {
                        levelUp();
                    }
                } else if (percentage >= 60) {
                    title = '×›×œ ×”×›×‘×•×“ ×ª×‘×•×¨! â­';
                    message = `×˜×•×‘ ×××•×“! ×”×©×’×ª ${percentage}% × ×›×•× ×•×ª<br>
                              ×¦×‘×¨×ª ${gameState.correctAnswersInRow} ×ª×©×•×‘×•×ª × ×›×•× ×•×ª ××ª×•×š 15<br>
                              ×¢×•×“ ×§×¦×ª ×ª×¨×’×•×œ ×•×ª×¢×œ×™ ×œ×¨××” ×”×‘××”! ğŸ’ª`;
                } else {
                    title = '×ª×‘×•×¨, ××ª ×‘×“×¨×š ×”× ×›×•× ×”! ğŸ’œ';
                    message = `×”×©×’×ª ${percentage}% × ×›×•× ×•×ª<br>
                              ×¦×‘×¨×ª ${gameState.correctAnswersInRow} ×ª×©×•×‘×•×ª × ×›×•× ×•×ª ××ª×•×š 15<br>
                              ×‘×•××™ × ×ª×¨×’×œ ×¢×•×“ ×§×¦×ª ×‘×¨××” ×”×–×•! ğŸ“š`;
                }
                
                document.getElementById('resultTitle').innerHTML = title;
                document.getElementById('resultMessage').innerHTML = message;
                      
                console.log('ğŸ“Š ×ª×•×¦××•×ª:', percentage + '% × ×›×•× ×•×ª');
            } catch (error) {
                console.error('âŒ ×©×’×™××” ×‘×”×¦×’×ª ×ª×•×¦××•×ª:', error);
            }
        }

        // Level up
        function levelUp() {
            try {
                if (gameState.currentLevel < 10) {
                    gameState.currentLevel++;
                    
                    const notification = document.createElement('div');
                    notification.className = 'level-up-notification';
                    notification.innerHTML = `ğŸ° ×¢×œ×™×ª ×œ×¨××” ${gameState.currentLevel}! ğŸ°<br>
                                            <small>×”×˜×™×¨×” ×©×œ×š ×’×“×œ×”!<br>××ª×’×¨×™× ×—×“×©×™× ××—×›×™×!</small>`;
                    document.body.appendChild(notification);
                    
                    setTimeout(() => notification.remove(), 3000);
                    
                    updateCastle();
                    console.log('ğŸ“ˆ ×¢×œ×™×™×” ×œ×¨××”:', gameState.currentLevel);
                }
            } catch (error) {
                console.error('âŒ ×©×’×™××” ×‘×¢×œ×™×™×” ×œ×¨××”:', error);
            }
        }

        // Update castle display
        function updateCastle() {
            try {
                const castleParts = document.querySelectorAll('.castle-part');
                castleParts.forEach((part, index) => {
                    if (index < gameState.currentLevel) {
                        part.classList.add('built');
                    }
                });
            } catch (error) {
                console.error('âŒ ×©×’×™××” ×‘×¢×“×›×•×Ÿ ×”×˜×™×¨×”:', error);
            }
        }

        // Next level function
        function nextLevel() {
            if (gameState.currentTopic && gameState.currentLevel <= 10) {
                startGame(gameState.currentTopic);
            } else {
                showMenu();
            }
        }

        // Update progress bar
        function updateProgress() {
            try {
                const progress = ((gameState.currentQuestion + 1) / 15) * 100;
                document.getElementById('progressFill').style.width = progress + '%';
                document.getElementById('progressText').textContent = Math.round(progress) + '%';
            } catch (error) {
                console.error('âŒ ×©×’×™××” ×‘×¢×“×›×•×Ÿ ×”×ª×§×“××•×ª:', error);
            }
        }

        // Update display
        function updateDisplay() {
            try {
                document.getElementById('currentScore').textContent = gameState.score;
                document.getElementById('currentLevel').textContent = gameState.currentLevel;
                document.getElementById('correctAnswers').textContent = `${gameState.correctAnswersInRow}/15`;
                
                updateCastle();
                saveGameState();
            } catch (error) {
                console.error('âŒ ×©×’×™××” ×‘×¢×“×›×•×Ÿ ×”×ª×¦×•×’×”:', error);
            }
        }

        // Show main menu
        function showMenu() {
            try {
                document.getElementById('gameScreen').classList.add('hidden');
                document.getElementById('resultScreen').classList.add('hidden');
                document.getElementById('menuScreen').classList.remove('hidden');
                console.log('ğŸ  ×—×–×¨×” ×œ×ª×¤×¨×™×˜ ×”×¨××©×™');
            } catch (error) {
                console.error('âŒ ×©×’×™××” ×‘×—×–×¨×” ×œ×ª×¤×¨×™×˜:', error);
            }
        }

        // Save game state to localStorage
        function saveGameState() {
            try {
                const gameData = {
                    score: gameState.score,
                    currentLevel: gameState.currentLevel
                };
                localStorage.setItem('tavorMathGameAdvanced', JSON.stringify(gameData));
            } catch (error) {
                console.error('âŒ ×©×’×™××” ×‘×©××™×¨×ª ×”××©×—×§:', error);
            }
        }

        // Load game state from localStorage
        function loadGameState() {
            try {
                const saved = localStorage.getItem('tavorMathGameAdvanced');
                if (saved) {
                    const data = JSON.parse(saved);
                    gameState.score = data.score || 0;
                    gameState.currentLevel = data.currentLevel || 1;
                    console.log('ğŸ’¾ × ×˜×¢×Ÿ ××¦×‘ ×©××•×¨:', data);
                }
            } catch (error) {
                console.error('âŒ ×©×’×™××” ×‘×˜×¢×™× ×ª ××¦×‘ ×©××•×¨:', error);
            }
        }

        // Initialize the game when page loads
        window.addEventListener('load', function() {
            console.log('ğŸŒŸ ×”×“×£ × ×˜×¢×Ÿ - ××ª×—×™×œ ××ª ×”××©×—×§ ×”××ª×§×“×...');
            initGame();
        });
        
        if (document.readyState === 'complete') {
            console.log('ğŸ“„ ×”××¡××š ×›×‘×¨ ××•×›×Ÿ - ××ª×—×™×œ ××™×™×“×™');
            initGame();
        }
        
        window.addEventListener('error', function(e) {
            console.error('ğŸš¨ ×©×’×™××” ×›×œ×œ×™×ª:', e.error);
        });
    </script>
</body>
</html>